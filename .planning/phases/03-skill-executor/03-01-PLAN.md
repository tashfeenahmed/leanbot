---
phase: 03-skill-executor
plan: 01
type: execute
---

<objective>
Create SkillExecutor class that runs skill scripts with proper environment setup and output capture.

Purpose: Enable the agent to execute any skill by spawning its script with SKILL_ARGS and capturing the JSON result.

Output: SkillExecutor class that can run bash skill (and future skills) end-to-end.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase context:**
@.planning/phases/02-bash-skill/02-01-SUMMARY.md
@.planning/phases/02-bash-skill/02-02-SUMMARY.md

**Skill script pattern to execute:**
@src/skills/bundled/bash/SKILL.md
@src/skills/bundled/bash/scripts/run.ts

**Established patterns from Phase 2:**
- Scripts read SKILL_ARGS from environment variable (JSON string)
- Scripts output JSON to stdout: { success, output, error, exitCode }
- SKILL_DIR env var provides workspace root
- Scripts are .ts files run with tsx, or .js/.sh with appropriate runners

**Key decisions:**
- 30-second default timeout for script execution
- Support .ts, .js, .sh script types with appropriate runners
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SkillExecutor class with script spawning</name>
  <files>src/skills/SkillExecutor.ts</files>
  <action>
Create SkillExecutor class that runs skill scripts:

```typescript
interface SkillExecuteOptions {
  skillPath: string;      // Path to skill directory (e.g., src/skills/bundled/bash)
  action: string;         // Action name from scripts mapping (e.g., "run")
  args: Record<string, unknown>;  // Arguments to pass as SKILL_ARGS
  workspaceRoot?: string; // Override workspace root (defaults to cwd)
  timeout?: number;       // Override default timeout
}

interface SkillResult {
  success: boolean;
  output: string;
  error?: string;
  exitCode: number;
}
```

**Implementation:**

1. `execute(options: SkillExecuteOptions): Promise<SkillResult>`
   - Load SKILL.md from skillPath
   - Parse YAML frontmatter to get scripts mapping
   - Find script path for the requested action (e.g., scripts.run)
   - Determine runner based on file extension:
     - `.ts` → `npx tsx`
     - `.js` → `node`
     - `.sh` → `bash`
   - Spawn process with environment:
     - SKILL_ARGS = JSON.stringify(args)
     - SKILL_DIR = workspaceRoot || process.cwd()
   - Capture stdout and stderr
   - Parse stdout as JSON (the skill's result)
   - Return SkillResult

2. `loadSkillConfig(skillPath: string): SkillConfig`
   - Read SKILL.md
   - Parse YAML frontmatter
   - Return { name, description, scripts, ... }

**Use child_process.spawn** (not exec) for streaming output and better control.

**Error cases:**
- SKILL.md not found → throw Error
- Script not found → throw Error
- Script crashes → return { success: false, error: stderr, exitCode }
- Invalid JSON output → return { success: false, error: "Invalid JSON output", exitCode: 1 }
  </action>
  <verify>
Test executor with bash skill:
```bash
# Create a quick test script
cat > /tmp/test-executor.ts << 'EOF'
import { SkillExecutor } from './src/skills/SkillExecutor';

const executor = new SkillExecutor();

async function test() {
  const result = await executor.execute({
    skillPath: './src/skills/bundled/bash',
    action: 'run',
    args: { command: 'echo hello world' }
  });
  console.log('Result:', JSON.stringify(result, null, 2));
}

test();
EOF

npx tsx /tmp/test-executor.ts
# Should output: { success: true, output: "hello world\n", exitCode: 0 }

# Verify TypeScript compiles
npx tsc --noEmit
```
  </verify>
  <done>SkillExecutor.execute() runs bash skill successfully, returns parsed JSON result</done>
</task>

<task type="auto">
  <name>Task 2: Add timeout handling and graceful shutdown</name>
  <files>src/skills/SkillExecutor.ts</files>
  <action>
Add timeout handling to SkillExecutor:

1. Add DEFAULT_TIMEOUT constant (30000ms = 30 seconds)

2. Implement timeout with graceful shutdown:
   - Start timer when process spawns
   - On timeout: send SIGTERM first
   - After 5 seconds if still running: send SIGKILL
   - Return result with exitCode 124 (standard timeout code)

3. Clean up on completion:
   - Clear timeout timer on normal exit
   - Remove event listeners to prevent memory leaks

**Mirror the timeout pattern from bash skill's run.ts** - it already handles this correctly.

4. Add optional `timeout` parameter to SkillExecuteOptions (overrides default)
  </action>
  <verify>
Test timeout handling:
```bash
# Test that timeout works (this command would hang forever)
cat > /tmp/test-timeout.ts << 'EOF'
import { SkillExecutor } from './src/skills/SkillExecutor';

const executor = new SkillExecutor();

async function test() {
  const result = await executor.execute({
    skillPath: './src/skills/bundled/bash',
    action: 'run',
    args: { command: 'sleep 100' },
    timeout: 2000  // 2 second timeout
  });
  console.log('Result:', JSON.stringify(result, null, 2));
  // Should show success: false, exitCode: 124 (timeout)
}

test();
EOF

npx tsx /tmp/test-timeout.ts
# Should complete in ~2 seconds with timeout error

npx tsc --noEmit
```
  </verify>
  <done>Timeout handling works, process killed gracefully after timeout, returns exitCode 124</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` succeeds
- [ ] SkillExecutor runs bash skill with echo command
- [ ] Timeout kills long-running commands
- [ ] Invalid skill path throws appropriate error
- [ ] Invalid JSON output is handled gracefully
</verification>

<success_criteria>
- Both tasks completed
- SkillExecutor can execute bash skill end-to-end
- Timeout handling prevents hung processes
- TypeScript compiles without errors
- All manual tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-skill-executor/03-01-SUMMARY.md`
</output>
