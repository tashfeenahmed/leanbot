---
phase: 06-telegram-memory-skills
plan: 02
type: execute
---

<objective>
Create telegram_send skill with singleton gateway pattern for subprocess access.

Purpose: Expose Telegram messaging as a skill, solving the subprocess isolation challenge identified in research.
Output: TelegramGateway singleton and working telegram_send skill.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-telegram-memory-skills/06-RESEARCH.md
@.planning/phases/06-telegram-memory-skills/06-01-SUMMARY.md

**Prior patterns to follow:**
@src/skills/bundled/browser/SKILL.md
@src/skills/bundled/browser/scripts/run.ts
@src/tools/browser/session.ts (for singleton pattern)

**Existing implementation:**
@src/channels/telegram.ts
@src/gateway/gateway.ts (for callback pattern context)

**From RESEARCH.md:**
- Challenge: Skills run as subprocess, can't access TelegramChannel directly
- Solution: Create TelegramGateway singleton (like BrowserSession pattern)
- Don't hand-roll: Use existing TelegramChannel.sendMessage(), formatMarkdownToHtml(), splitMessage()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TelegramGateway singleton</name>
  <files>src/channels/telegram-gateway.ts</files>
  <action>
Create TelegramGateway singleton following BrowserSession pattern:

```typescript
// Module-level singleton instance
let instance: TelegramGateway | null = null;

export class TelegramGateway {
  private channel: TelegramChannel | null = null;

  static getInstance(): TelegramGateway {
    if (!instance) {
      instance = new TelegramGateway();
    }
    return instance;
  }

  static resetInstance(): void {
    instance = null;
  }

  setChannel(channel: TelegramChannel): void {
    this.channel = channel;
  }

  isAvailable(): boolean {
    return this.channel !== null;
  }

  async sendMessage(chatId: string | number, message: string): Promise<boolean> {
    if (!this.channel) {
      throw new Error('Telegram channel not initialized. Call setChannel() first.');
    }
    await this.channel.sendMessage(chatId, message);
    return true;
  }

  async sendFile(chatId: string | number, filePath: string, caption?: string): Promise<boolean> {
    if (!this.channel) {
      throw new Error('Telegram channel not initialized. Call setChannel() first.');
    }
    return this.channel.sendFile(chatId, filePath, caption);
  }
}
```

Export from src/channels/index.ts.

Key points:
- Singleton pattern matches BrowserSession
- Methods delegate to TelegramChannel (don't reimplement)
- Throws clear error if not initialized
- Include resetInstance() for testing
  </action>
  <verify>npx tsc --noEmit src/channels/telegram-gateway.ts</verify>
  <done>TelegramGateway singleton compiles and exports correctly</done>
</task>

<task type="auto">
  <name>Task 2: Wire TelegramGateway in Gateway initialization</name>
  <files>src/gateway/gateway.ts</files>
  <action>
Update Gateway.initialize() to wire TelegramGateway singleton:

After TelegramChannel is created (around line 377-387):
```typescript
// After: this.telegramChannel = new TelegramChannel({...})
import { TelegramGateway } from '../channels/telegram-gateway.js';

// Wire singleton for skill access
TelegramGateway.getInstance().setChannel(this.telegramChannel);
```

This ensures skills can access Telegram via the singleton after gateway initialization.

Add cleanup in Gateway.stop():
```typescript
// After: await this.telegramChannel.stop();
TelegramGateway.resetInstance();
```
  </action>
  <verify>grep -n "TelegramGateway" src/gateway/gateway.ts shows import and setChannel call</verify>
  <done>Gateway wires TelegramGateway singleton during initialization and cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Create telegram_send skill</name>
  <files>src/skills/bundled/telegram_send/SKILL.md, src/skills/bundled/telegram_send/scripts/run.ts</files>
  <action>
Create SKILL.md with:
- name: telegram_send
- description: Send a message to a Telegram user
- user-invocable: true (can use as /telegram_send slash command)
- triggers: [telegram, send message, message user, notify]

Parameters:
- chat_id (required): Telegram chat ID or user ID to send to
- message (required): Message text to send (supports markdown)

Create scripts/run.ts:
1. Import TelegramGateway from channels/telegram-gateway.js
2. Parse SKILL_ARGS for chat_id and message
3. Validate both required
4. Check TelegramGateway.getInstance().isAvailable()
5. Call sendMessage(chat_id, message)
6. Output JSON { success: true, output: "Message sent to {chat_id}", exitCode: 0 }

Error handling:
- Gateway not available: { success: false, error: "Telegram not initialized", exitCode: 1 }
- Missing parameters: { success: false, error: "Missing required parameter: {param}", exitCode: 1 }
- Send failure: { success: false, error: message, exitCode: 1 }
  </action>
  <verify>npx tsc --noEmit src/skills/bundled/telegram_send/scripts/run.ts && ls src/skills/bundled/telegram_send/SKILL.md</verify>
  <done>telegram_send skill created with SKILL.md and run.ts, compiles without errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TelegramGateway singleton exists and compiles
- [ ] Gateway.ts imports and wires TelegramGateway
- [ ] telegram_send/SKILL.md exists with valid frontmatter
- [ ] telegram_send/scripts/run.ts exists and compiles
- [ ] No TypeScript errors: `npx tsc --noEmit`
</verification>

<success_criteria>
- TelegramGateway singleton at src/channels/telegram-gateway.ts
- Gateway initialization wires singleton
- telegram_send skill folder exists at src/skills/bundled/telegram_send/
- SKILL.md documents chat_id and message parameters
- run.ts uses singleton pattern for Telegram access
- Phase 6 complete with both skills implemented
</success_criteria>

<output>
After completion, create `.planning/phases/06-telegram-memory-skills/06-02-SUMMARY.md`

Include in summary:
- TelegramGateway singleton pattern decision
- How it mirrors BrowserSession for consistency
- Phase 6 complete flag
</output>
